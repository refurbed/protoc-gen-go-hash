// Copyright (c) 2022 Refurbed GmbH. All rights reserved.
// Use of this source code is governed by an Apache-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"os"
	"path/filepath"

	"google.golang.org/protobuf/types/pluginpb"

	"google.golang.org/protobuf/compiler/protogen"
)

const (
	genGoDocURL            = "https://github.com/refurbed/protoc-gen-go-hash"
	protocGenGoHashVersion = "0.0.3"
)

func main() {
	if len(os.Args) == 2 && os.Args[1] == "--version" {
		fmt.Printf("%v %v\n", filepath.Base(os.Args[0]), protocGenGoHashVersion)
		os.Exit(0)
	}
	if len(os.Args) == 2 && os.Args[1] == "--help" {
		fmt.Printf("See " + genGoDocURL + " for usage information.\n")
		os.Exit(0)
	}

	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}

		return nil
	})
}

// generateFile generates a _hash.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) {
	gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL) //nolint:nosnakecase
	filename := file.GeneratedFilenamePrefix + "_hash.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-hash. DO NOT EDIT.")
	g.P("// versions:")

	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}

	g.P("// \tprotoc-gen-go-hash ", "v", protocGenGoHashVersion)
	g.P("// \tprotoc             ", protocVersion)

	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}

	g.P()
	g.P("package ", file.GoPackageName)
	if len(file.Messages) > 0 {
		g.P()
		g.P("import(")
		g.P(`"fmt"`)
		g.P("")
		g.P(`"github.com/mitchellh/hashstructure/v2"`)
		g.P(")")
	}
	g.P()

	for _, msg := range file.Messages {
		g.P("func (x *", msg.GoIdent, ") Hash() (uint64, error) {")
		g.P("if x == nil {")
		g.P(`return 0, fmt.Errorf("message is defined as nil")`)
		g.P("}")
		g.P("")
		g.P("return hashstructure.Hash(*x, hashstructure.FormatV2, nil)")
		g.P("}")
	}
}
